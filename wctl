#!/usr/bin/env bash
#
# wctl - Window Control CLI
# A wrapper for the GNOME Shell Window Control D-Bus extension
#

set -euo pipefail

# D-Bus service details
DBUS_DEST="org.gnome.Shell"
DBUS_PATH="/org/gnome/Shell/Extensions/WindowControl"
DBUS_IFACE="org.gnome.Shell.Extensions.WindowControl"

# Colors for output (disabled if not a tty)
if [[ -t 1 ]]; then
    BOLD='\033[1m'
    DIM='\033[2m'
    GREEN='\033[32m'
    YELLOW='\033[33m'
    RED='\033[31m'
    RESET='\033[0m'
else
    BOLD=''
    DIM=''
    GREEN=''
    YELLOW=''
    RED=''
    RESET=''
fi

# Print error message and exit
die() {
    echo -e "${RED}Error:${RESET} $1" >&2
    exit 1
}

# Call D-Bus method and return raw output
# Usage: dbus_call METHOD [ARGS...]
dbus_call() {
    local method="$1"
    shift
    
    local result
    if ! result=$(gdbus call --session \
        --dest "$DBUS_DEST" \
        --object-path "$DBUS_PATH" \
        --method "${DBUS_IFACE}.${method}" \
        "$@" 2>&1); then
        
        # Check for common errors
        if [[ "$result" == *"was not provided"* ]] || [[ "$result" == *"does not exist"* ]]; then
            die "Window Control extension is not running. Enable it in GNOME Extensions."
        fi
        die "D-Bus call failed: $result"
    fi
    
    echo "$result"
}

# Truncate string to max length with ellipsis
truncate() {
    local str="$1"
    local max="$2"
    
    if [[ ${#str} -gt $max ]]; then
        echo "${str:0:$((max-3))}..."
    else
        echo "$str"
    fi
}

# Show help message
show_help() {
    cat << 'EOF'
wctl - Window Control CLI

USAGE:
    wctl <COMMAND> [OPTIONS]

LISTING COMMANDS:
    list              List all windows in a table format
    list --json       List all windows with detailed JSON output
    focused           Show detailed info for the focused window
    focused --json    Show focused window info as JSON

ACTIVATION COMMANDS:
    activate <ID>           Activate by window ID
    activate -t <TITLE>     Activate by exact title match
    activate -s <SUBSTR>    Activate by title substring
    activate -c <CLASS>     Activate by WM class
    activate -p <PID>       Activate by process ID
    focus <ID>              Focus window by ID (without raising)

INFO COMMANDS:
    info <ID>             Show detailed window information
    info <ID> --json      Show window information as JSON

GEOMETRY COMMANDS:
    move <ID> <X> <Y>                   Move window to position
    resize <ID> <WIDTH> <HEIGHT>        Resize window
    move-resize <ID> <X> <Y> <W> <H>    Move and resize atomically
    to-monitor <ID> <MONITOR>           Move window to monitor index

STATE COMMANDS:
    minimize <ID>           Minimize window
    unminimize <ID>         Restore from minimize
    maximize <ID>           Maximize window
    unmaximize <ID>         Restore from maximize
    fullscreen <ID>         Make window fullscreen
    unfullscreen <ID>       Exit fullscreen mode
    above <ID> on|off       Set always-on-top state
    sticky <ID> on|off      Set sticky (all workspaces) state
    close <ID>              Close window (polite request)

OTHER:
    help                    Show this help message

EXAMPLES:
    wctl list                         # Show all windows
    wctl list --json                  # Get detailed JSON output
    wctl focused                      # Show detailed focused window info
    wctl focused --json               # Get focused window as JSON
    wctl activate 12345               # Activate window by ID
    wctl activate -c Firefox          # Activate Firefox window
    wctl activate -s "Visual"         # Activate window with "Visual" in title
    wctl info 12345                   # Show detailed window info
    wctl info 12345 --json            # Get window info as JSON
    wctl move 12345 100 100           # Move window to (100, 100)
    wctl resize 12345 800 600         # Resize to 800x600
    wctl maximize 12345               # Maximize window
    wctl above 12345 on               # Set always-on-top
    wctl close 12345                  # Close window

ENVIRONMENT:
    The Window Control GNOME Shell extension must be enabled.

EOF
}

# List windows in table format
cmd_list() {
    local raw
    raw=$(dbus_call "List")
    
    # gdbus output format: ([...],)
    # Each window: (uint64 ID, 'title', 'wm_class', 'wm_class_instance', 'sandboxed_app_id', bool, int32, int32, int32, int32)
    
    # Print header
    printf "${BOLD}%-12s %-40s %-20s %-10s %-8s %-7s${RESET}\n" \
        "ID" "TITLE" "WM_CLASS" "WORKSPACE" "MONITOR" "FOCUSED"
    printf "%s\n" "$(printf '%.0s-' {1..100})"
    
    # Parse the GVariant output
    # Remove outer ([...],) wrapper and process each tuple
    # The format is: (uint64 123, 'title', 'class', 'instance', 'sandbox', true/false, int32 0, int32 0, int32 1234, int32 0)
    
    # Extract the array content (between outer parentheses)
    local content="${raw#(}"
    content="${content%,)}"
    
    # Check for empty list
    if [[ "$content" == "[]" ]] || [[ -z "$content" ]]; then
        echo "No windows found."
        return
    fi
    
    # Remove outer brackets
    content="${content#\[}"
    content="${content%\]}"
    
    # Process each window tuple using POSIX-compatible awk
    # Uses gsub/sub instead of gawk-specific match() with capture groups
    echo "$content" | awk '
    BEGIN {
        RS = "\\), \\("   # Split on tuple boundaries
        FS = ""
    }
    
    # Helper: extract number after optional "uint64 " or "int32 " prefix
    function extract_number(s, result) {
        # Remove type prefix if present
        gsub(/^uint64 /, "", s)
        gsub(/^int32 /, "", s)
        # Match leading number (possibly negative)
        if (match(s, /^-?[0-9]+/)) {
            return substr(s, RSTART, RLENGTH)
        }
        return ""
    }
    
    # Helper: extract quoted string (returns content without quotes)
    function extract_quoted(s, result) {
        if (match(s, /^'\''[^'\'']*'\''/)) {
            result = substr(s, RSTART + 1, RLENGTH - 2)
            return result
        }
        return ""
    }
    
    # Helper: find position after quoted string
    function skip_quoted(s) {
        if (match(s, /^'\''[^'\'']*'\''/)) {
            return RLENGTH
        }
        return 0
    }
    
    {
        # Clean up the record
        gsub(/^\(/, "", $0)
        gsub(/\)$/, "", $0)
        
        line = $0
        
        # Field 1: ID (uint64 NUMBER or just NUMBER)
        id = extract_number(line)
        # Skip past the ID field
        sub(/^(uint64 )?[0-9]+/, "", line)
        sub(/^, */, "", line)
        
        # Field 2: title (quoted string)
        title = extract_quoted(line)
        skip_len = skip_quoted(line)
        if (skip_len > 0) {
            line = substr(line, skip_len + 1)
        }
        sub(/^, */, "", line)
        
        # Field 3: wm_class (quoted string)
        wm_class = extract_quoted(line)
        skip_len = skip_quoted(line)
        if (skip_len > 0) {
            line = substr(line, skip_len + 1)
        }
        sub(/^, */, "", line)
        
        # Field 4: wm_class_instance (quoted string) - skip
        skip_len = skip_quoted(line)
        if (skip_len > 0) {
            line = substr(line, skip_len + 1)
        }
        sub(/^, */, "", line)
        
        # Field 5: sandboxed_app_id (quoted string) - skip
        skip_len = skip_quoted(line)
        if (skip_len > 0) {
            line = substr(line, skip_len + 1)
        }
        sub(/^, */, "", line)
        
        # Field 6: is_focused (true/false)
        focused = ""
        if (match(line, /^true/)) {
            focused = "*"
            line = substr(line, 5)
        } else if (match(line, /^false/)) {
            focused = ""
            line = substr(line, 6)
        }
        sub(/^, */, "", line)
        
        # Field 7: workspace (int32 NUMBER or just NUMBER)
        workspace = extract_number(line)
        if (workspace == "") workspace = "-"
        # Skip past workspace field
        sub(/^(int32 )?-?[0-9]+/, "", line)
        sub(/^, */, "", line)
        
        # Field 8: monitor (int32 NUMBER or just NUMBER)
        monitor = extract_number(line)
        if (monitor == "") monitor = "-"
        
        # Truncate title if too long
        if (length(title) > 37) {
            title = substr(title, 1, 37) "..."
        }
        
        # Format workspace display
        if (workspace == "-1") {
            workspace = "all"
        }
        
        # Print formatted row
        printf "%-12s %-40s %-20s %-10s %-8s %-7s\n", id, title, wm_class, workspace, monitor, focused
    }
    '
}

# List windows as JSON (detailed)
cmd_list_json() {
    local raw
    raw=$(dbus_call "ListDetailed")
    
    # The output is: ('JSON_STRING',)
    # Extract the JSON string from GVariant wrapper
    local json="${raw#(\'}"
    json="${json%\',)}"
    
    # Handle escaped quotes if any
    json="${json//\\\'/\'}"
    
    echo "$json"
}

# Activate a window
# Usage: cmd_activate [OPTIONS] [ID]
cmd_activate() {
    local mode="id"
    local value=""
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t)
                mode="title"
                shift
                [[ $# -eq 0 ]] && die "Option -t requires a title argument"
                value="$1"
                shift
                ;;
            -s)
                mode="substring"
                shift
                [[ $# -eq 0 ]] && die "Option -s requires a substring argument"
                value="$1"
                shift
                ;;
            -c)
                mode="class"
                shift
                [[ $# -eq 0 ]] && die "Option -c requires a WM class argument"
                value="$1"
                shift
                ;;
            -p)
                mode="pid"
                shift
                [[ $# -eq 0 ]] && die "Option -p requires a PID argument"
                value="$1"
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                # Positional argument (window ID)
                mode="id"
                value="$1"
                shift
                ;;
        esac
    done
    
    [[ -z "$value" ]] && die "Usage: wctl activate <ID> or wctl activate -t|-s|-c|-p <value>"
    
    local raw success
    case "$mode" in
        id)
            # Validate numeric ID
            [[ ! "$value" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
            raw=$(dbus_call "Activate" "$value")
            ;;
        title)
            raw=$(dbus_call "ActivateByTitle" "$value")
            ;;
        substring)
            raw=$(dbus_call "ActivateByTitleSubstring" "$value")
            ;;
        class)
            raw=$(dbus_call "ActivateByWmClass" "$value")
            ;;
        pid)
            # Validate numeric PID
            [[ ! "$value" =~ ^[0-9]+$ ]] && die "PID must be a number"
            raw=$(dbus_call "ActivateByPid" "$value")
            ;;
    esac
    
    # Parse result - format is (true,) or (false,)
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window activated"
    else
        echo "Window not found"
        exit 1
    fi
}

# Focus a window by ID (without raising)
cmd_focus() {
    local id="${1:-}"
    
    [[ -z "$id" ]] && die "Usage: wctl focus <ID>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local raw
    raw=$(dbus_call "Focus" "$id")
    
    # Parse result - format is (true,) or (false,)
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window focused"
    else
        echo "Window not found"
        exit 1
    fi
}

# Show focused window
# Usage: cmd_focused [--json]
cmd_focused() {
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                die "Unexpected argument: $1"
                ;;
        esac
    done
    
    local raw
    raw=$(dbus_call "GetFocused")
    
    # Output format: (uint64 ID, 'title', 'wm_class')
    # Extract window ID
    local id
    if [[ "$raw" =~ uint64\ ([0-9]+) ]]; then
        id="${BASH_REMATCH[1]}"
    elif [[ "$raw" =~ ^\(([0-9]+), ]]; then
        id="${BASH_REMATCH[1]}"
    else
        id="0"
    fi
    
    # Check if no window is focused
    if [[ "$id" == "0" ]]; then
        echo "No window focused"
        return
    fi
    
    # Delegate to cmd_info with the focused window ID
    if [[ "$json_output" == true ]]; then
        cmd_info "$id" --json
    else
        cmd_info "$id"
    fi
}

# ============================================================================
# Info Commands
# ============================================================================

# Show detailed info for a single window
# Usage: cmd_info <ID> [--json]
cmd_info() {
    local id=""
    local json_output=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --json)
                json_output=true
                shift
                ;;
            -*)
                die "Unknown option: $1"
                ;;
            *)
                if [[ -z "$id" ]]; then
                    id="$1"
                else
                    die "Unexpected argument: $1"
                fi
                shift
                ;;
        esac
    done
    
    [[ -z "$id" ]] && die "Usage: wctl info <ID> [--json]"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    # Get detailed window list as JSON
    local raw
    raw=$(dbus_call "ListDetailed")
    
    # Extract the JSON string from GVariant wrapper
    local json="${raw#(\'}"
    json="${json%\',)}"
    json="${json//\\\'/\'}"
    
    # Find the window with matching ID using jq
    local window
    window=$(echo "$json" | jq -e --arg id "$id" '.[] | select(.id == ($id | tonumber))' 2>/dev/null) || {
        echo "Window not found: $id"
        exit 1
    }
    
    if [[ "$json_output" == true ]]; then
        # Output raw JSON for this window
        echo "$window"
    else
        # Output table format
        local title wm_class wm_instance pid workspace monitor focused
        local x y width height states
        
        title=$(echo "$window" | jq -r '.title')
        wm_class=$(echo "$window" | jq -r '.wm_class')
        wm_instance=$(echo "$window" | jq -r '.wm_class_instance')
        pid=$(echo "$window" | jq -r '.pid')
        workspace=$(echo "$window" | jq -r '.workspace_index')
        monitor=$(echo "$window" | jq -r '.monitor_index')
        focused=$(echo "$window" | jq -r 'if .has_focus then "yes" else "no" end')
        x=$(echo "$window" | jq -r '.frame_rect.x')
        y=$(echo "$window" | jq -r '.frame_rect.y')
        width=$(echo "$window" | jq -r '.frame_rect.width')
        height=$(echo "$window" | jq -r '.frame_rect.height')
        
        # Build states list from boolean flags
        local state_list=()
        [[ $(echo "$window" | jq -r '.is_maximized') == "true" ]] && state_list+=("maximized")
        [[ $(echo "$window" | jq -r '.is_minimized') == "true" ]] && state_list+=("minimized")
        [[ $(echo "$window" | jq -r '.is_fullscreen') == "true" ]] && state_list+=("fullscreen")
        [[ $(echo "$window" | jq -r '.is_above') == "true" ]] && state_list+=("above")
        [[ $(echo "$window" | jq -r '.is_on_all_workspaces') == "true" ]] && state_list+=("sticky")
        
        if [[ ${#state_list[@]} -gt 0 ]]; then
            states=$(IFS=', '; echo "${state_list[*]}")
        else
            states="none"
        fi
        
        # Format workspace display
        if [[ "$workspace" == "-1" ]]; then
            workspace="all"
        fi
        
        # Print table output
        echo "Window: $id"
        echo "Title: $title"
        echo "Class: $wm_class"
        echo "Instance: $wm_instance"
        echo "PID: $pid"
        echo "Workspace: $workspace"
        echo "Monitor: $monitor"
        echo "Focused: $focused"
        echo "Position: $x, $y"
        echo "Size: $width x $height"
        echo "States: $states"
    fi
}

# ============================================================================
# Geometry Commands
# ============================================================================

# Move window
cmd_move() {
    local id="${1:-}"
    local x="${2:-}"
    local y="${3:-}"
    
    [[ -z "$id" || -z "$x" || -z "$y" ]] && die "Usage: wctl move <ID> <X> <Y>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$x" =~ ^-?[0-9]+$ ]] && die "X coordinate must be a number"
    [[ ! "$y" =~ ^-?[0-9]+$ ]] && die "Y coordinate must be a number"
    
    local raw
    raw=$(dbus_call "Move" "$id" "$x" "$y")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window moved"
    else
        echo "Window not found"
        exit 1
    fi
}

# Resize window
cmd_resize() {
    local id="${1:-}"
    local width="${2:-}"
    local height="${3:-}"
    
    [[ -z "$id" || -z "$width" || -z "$height" ]] && die "Usage: wctl resize <ID> <WIDTH> <HEIGHT>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$width" =~ ^[0-9]+$ ]] && die "Width must be a positive number"
    [[ ! "$height" =~ ^[0-9]+$ ]] && die "Height must be a positive number"
    
    local raw
    raw=$(dbus_call "Resize" "$id" "$width" "$height")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window resized"
    else
        echo "Window not found"
        exit 1
    fi
}

# Move and resize window
cmd_move_resize() {
    local id="${1:-}"
    local x="${2:-}"
    local y="${3:-}"
    local width="${4:-}"
    local height="${5:-}"
    
    [[ -z "$id" || -z "$x" || -z "$y" || -z "$width" || -z "$height" ]] && \
        die "Usage: wctl move-resize <ID> <X> <Y> <WIDTH> <HEIGHT>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$x" =~ ^-?[0-9]+$ ]] && die "X coordinate must be a number"
    [[ ! "$y" =~ ^-?[0-9]+$ ]] && die "Y coordinate must be a number"
    [[ ! "$width" =~ ^[0-9]+$ ]] && die "Width must be a positive number"
    [[ ! "$height" =~ ^[0-9]+$ ]] && die "Height must be a positive number"
    
    local raw
    raw=$(dbus_call "MoveResize" "$id" "$x" "$y" "$width" "$height")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window moved and resized"
    else
        echo "Window not found"
        exit 1
    fi
}

# Move window to monitor
cmd_to_monitor() {
    local id="${1:-}"
    local monitor="${2:-}"
    
    [[ -z "$id" || -z "$monitor" ]] && die "Usage: wctl to-monitor <ID> <MONITOR>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    [[ ! "$monitor" =~ ^[0-9]+$ ]] && die "Monitor index must be a non-negative number"
    
    local raw
    raw=$(dbus_call "MoveToMonitor" "$id" "$monitor")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "Window moved to monitor $monitor"
    else
        echo "Window not found"
        exit 1
    fi
}



# ============================================================================
# State Commands
# ============================================================================

# Helper for simple window state commands
# Usage: cmd_simple_state METHOD MESSAGE_SUCCESS
cmd_simple_state() {
    local method="$1"
    local success_msg="$2"
    local id="${3:-}"
    
    [[ -z "$id" ]] && die "Usage: wctl ${method,,} <ID>"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local raw
    raw=$(dbus_call "$method" "$id")
    
    if [[ "$raw" == "(true,)" ]]; then
        echo "$success_msg"
    else
        echo "Window not found"
        exit 1
    fi
}

cmd_minimize() {
    cmd_simple_state "Minimize" "Window minimized" "$@"
}

cmd_unminimize() {
    cmd_simple_state "Unminimize" "Window unminimized" "$@"
}

cmd_maximize() {
    cmd_simple_state "Maximize" "Window maximized" "$@"
}

cmd_unmaximize() {
    cmd_simple_state "Unmaximize" "Window unmaximized" "$@"
}

cmd_fullscreen() {
    cmd_simple_state "Fullscreen" "Window fullscreened" "$@"
}

cmd_unfullscreen() {
    cmd_simple_state "Unfullscreen" "Window unfullscreened" "$@"
}

cmd_close() {
    cmd_simple_state "Close" "Window closed" "$@"
}

# Set above (always-on-top) state
cmd_above() {
    local id="${1:-}"
    local state="${2:-}"
    
    [[ -z "$id" || -z "$state" ]] && die "Usage: wctl above <ID> on|off"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local above
    case "$state" in
        on|true|1)
            above="true"
            ;;
        off|false|0)
            above="false"
            ;;
        *)
            die "State must be 'on' or 'off'"
            ;;
    esac
    
    local raw
    raw=$(dbus_call "SetAbove" "$id" "$above")
    
    if [[ "$raw" == "(true,)" ]]; then
        if [[ "$above" == "true" ]]; then
            echo "Window set to always-on-top"
        else
            echo "Window removed from always-on-top"
        fi
    else
        echo "Window not found"
        exit 1
    fi
}

# Set sticky (all workspaces) state
cmd_sticky() {
    local id="${1:-}"
    local state="${2:-}"
    
    [[ -z "$id" || -z "$state" ]] && die "Usage: wctl sticky <ID> on|off"
    [[ ! "$id" =~ ^[0-9]+$ ]] && die "Window ID must be a number"
    
    local sticky
    case "$state" in
        on|true|1)
            sticky="true"
            ;;
        off|false|0)
            sticky="false"
            ;;
        *)
            die "State must be 'on' or 'off'"
            ;;
    esac
    
    local raw
    raw=$(dbus_call "SetSticky" "$id" "$sticky")
    
    if [[ "$raw" == "(true,)" ]]; then
        if [[ "$sticky" == "true" ]]; then
            echo "Window set to all workspaces"
        else
            echo "Window removed from all workspaces"
        fi
    else
        echo "Window not found"
        exit 1
    fi
}

# Main entry point
main() {
    # Handle no arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi
    
    local cmd="$1"
    shift
    
    case "$cmd" in
        # Listing commands
        list)
            if [[ "${1:-}" == "--json" ]]; then
                cmd_list_json
            else
                cmd_list
            fi
            ;;
        focused)
            cmd_focused "$@"
            ;;
        
        # Info commands
        info)
            cmd_info "$@"
            ;;
        
        # Activation commands
        activate)
            cmd_activate "$@"
            ;;
        focus)
            cmd_focus "$@"
            ;;
        
        # Geometry commands
        move)
            cmd_move "$@"
            ;;
        resize)
            cmd_resize "$@"
            ;;
        move-resize)
            cmd_move_resize "$@"
            ;;
        to-monitor)
            cmd_to_monitor "$@"
            ;;
        
        # State commands
        minimize)
            cmd_minimize "$@"
            ;;
        unminimize)
            cmd_unminimize "$@"
            ;;
        maximize)
            cmd_maximize "$@"
            ;;
        unmaximize)
            cmd_unmaximize "$@"
            ;;
        fullscreen)
            cmd_fullscreen "$@"
            ;;
        unfullscreen)
            cmd_unfullscreen "$@"
            ;;
        above)
            cmd_above "$@"
            ;;
        sticky)
            cmd_sticky "$@"
            ;;
        close)
            cmd_close "$@"
            ;;
        
        # Help
        help|--help|-h)
            show_help
            ;;
        *)
            die "Unknown command: $cmd. Run 'wctl help' for usage."
            ;;
    esac
}

main "$@"
